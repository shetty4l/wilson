name: Release

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]

concurrency:
  group: release
  cancel-in-progress: false

jobs:
  release:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Compute next version
        id: version
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.1.0")
          echo "latest_tag=${LATEST_TAG}" >> "$GITHUB_OUTPUT"

          # Strip 'v' prefix and split into major.minor.patch
          VERSION="${LATEST_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Scan commits since last tag for [minor] or [major] bump markers
          # created by: bun run version:bump <minor|major>
          COMMITS_SINCE="$(git log "${LATEST_TAG}..HEAD" --format='%s' 2>/dev/null || echo "")"
          if echo "$COMMITS_SINCE" | grep -q '\[major\]'; then
            NEXT_VERSION="$((MAJOR + 1)).0.0"
            BUMP_LEVEL="major"
          elif echo "$COMMITS_SINCE" | grep -q '\[minor\]'; then
            NEXT_VERSION="${MAJOR}.$((MINOR + 1)).0"
            BUMP_LEVEL="minor"
          else
            NEXT_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
            BUMP_LEVEL="patch"
          fi

          echo "bump_level=${BUMP_LEVEL}" >> "$GITHUB_OUTPUT"
          echo "next_version=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "next_tag=v${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "Releasing: v${NEXT_VERSION} (previous: ${LATEST_TAG}, bump: ${BUMP_LEVEL})"

      - name: Write VERSION file
        run: echo "${{ steps.version.outputs.next_version }}" > VERSION

      - name: Write BUILD_META.json
        run: |
          SHA="${{ github.event.workflow_run.head_sha }}"
          SHORT_SHA="${SHA:0:7}"
          BRANCH="${{ github.event.workflow_run.head_branch }}"
          TITLE="$(git log -1 --format='%s' "$SHA")"
          BUILD_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          jq -n \
            --arg sha "$SHA" \
            --arg shortSha "$SHORT_SHA" \
            --arg branch "$BRANCH" \
            --arg title "$TITLE" \
            --arg buildTime "$BUILD_TIME" \
            '{
              gitSha: $sha,
              gitShortSha: $shortSha,
              gitBranch: $branch,
              commitTitle: $title,
              buildTimeUtc: $buildTime
            }' > BUILD_META.json

      - name: Create source tarball
        run: |
          TAG="${{ steps.version.outputs.next_tag }}"
          tar czf "wilson-${TAG}.tar.gz" \
            --exclude='node_modules' \
            --exclude='.git' \
            --exclude='test' \
            --exclude='.husky' \
            --exclude='.DS_Store' \
            --exclude='dist' \
            src/ \
            deploy/ \
            scripts/install.sh \
            package.json \
            bun.lock \
            tsconfig.json \
            biome.json \
            VERSION \
            BUILD_META.json

      - name: Create tag and release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          TAG="${{ steps.version.outputs.next_tag }}"

          git tag "${TAG}"
          git push origin "${TAG}"

          gh release create "${TAG}" \
            --title "Release ${TAG}" \
            --notes "Automated release ${TAG}" \
            "wilson-${TAG}.tar.gz" \
            "scripts/install.sh"
